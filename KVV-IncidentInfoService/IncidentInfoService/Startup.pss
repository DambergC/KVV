<File version="3.2">
  <Code><![CDATA[# Warning: Do not rename Start-MyService, Invoke-MyService and Stop-MyService functions


function Start-MyService
{
	# Place one time startup code here.
	# Initialize global variables and open connections if needed
	$global:bRunService = $true
	$global:bServiceRunning = $false
	$global:bServicePaused = $false
	[XML]$config = Get-Content "C:\Program Files\IncidentInfo\Service\IncidentInfoServiceSettings.xml"
	$filepath = $config.Configuration.Filepath
	
	$filesharesearch = $config.Configuration.Filesharesearch
	$RegistrySearch = $config.Configuration.RegistrySearch
	
	if ($filesharesearch -eq 1)
	{
		Write-EventLog -LogName Application -EventId 1 -Message "Service start and getting info from:$filepath" -Source IncidentInfoService
	}
	
	if ($RegistrySearch -eq 1)
	{
		Write-EventLog -LogName Application -EventId 1 -Message "Service start and getting info from: HKEY_LOCAL_MACHINE\SOFTWARE\DriftInfo" -Source IncidentInfoService
	}
	
	

}

function Invoke-MyService
{
	$global:bServiceRunning = $true
	while($global:bRunService) {
		try 
		{
			if($global:bServicePaused -eq $false) #Only act if service is not paused
			{
				
				[XML]$config = Get-Content "C:\Program Files\IncidentInfo\Service\IncidentInfoServiceSettings.xml"
				$filepath = $config.Configuration.Filepath
				
				$filesharesearch = $config.Configuration.Filesharesearch
				$RegistrySearch = $config.Configuration.RegistrySearch
				
				
				if ($filesharesearch -eq 1)
				{
					
					[XML]$configIncident = Get-Content $filepath
					# Read Start and Stop times
					$startStr = $configIncident.Configuration.Start.trim()
					$stopStr = $configIncident.Configuration.Stop.trim()
					
					try
					{
						# Try ParseExact first
						$startTime = [datetime]::ParseExact($startStr, "yyyy-MM-dd HH:mm:ss", $null)
						$stopTime = [datetime]::ParseExact($stopStr, "yyyy-MM-dd HH:mm:ss", $null)
					}
					catch
					{
						# Fallback: Use Parse if ParseExact fails
						$startTime = [datetime]::Parse($startStr)
						$stopTime = [datetime]::Parse($stopStr)
					}
					
					# Current local time
					$now = Get-Date
					
					# Check if current time is within the range
					if ($now -ge $startTime -and $now -le $stopTime)
					{
						Write-EventLog -LogName Application -EventId 1 -Message "Current time $now is within the range. Launching application..." -Source IncidentInfoService
						# This script detects the active user session and launches your application there
						$query = query session | Where-Object { $_ -match 'Active' }
						$sessionId = ($query -split ' +')[1]
						
						# Path to Windows executable that can create processes in other sessions
						$processPath = "C:\Program Files\IncidentInfo\PsExec64.exe"
						
						# Launch your application in the active session with accepteula parameter
						Start-Process -FilePath $processPath -ArgumentList "-accepteula -i $sessionId -d -s `"C:\Program Files\IncidentInfo\Driftstorning.exe`""
					}
					else
					{
						Write-EventLog -LogName Application -EventId 1 -Message "Current time $now is NOT within the range. Application will not start." -Source IncidentInfoService
						#Write-Host "Current time $now is NOT within the range. Application will not start."
					}
				} #e.g. $ProcessList = Get-Process solitaire -ErrorAction SilentlyContinue

				
				#Write-EventLog -LogName Application -EventId 1 -Message "Path to infoxml:$filepath" -Source IncidentInfoService
				# Use Write-Host or any other PowerShell output function to write to the System's application log
			}
		}
		catch
		{
			# Log exception in application log
			Write-Host $_.Exception.Message 
		}
		# Adjust sleep timing to determine how often your service becomes active.
		if($global:bServicePaused -eq $true) 
		{
			Start-Sleep -Seconds 60 # if the service is paused we sleep longer between checks.
			
			[XML]$config = Get-Content "C:\Program Files\IncidentInfo\Service\IncidentInfoServiceSettings.xml"
			$filepath = $config.Configuration.Filepath
			
			#Write-EventLog -LogName Application -EventId 1 -Message "Path to infoxml:$filepath" -Source IncidentInfoService
			
		}
		else 
		{
			Start-Sleep –Seconds 30 # a lower number will make your service active more often and use more CPU cycles
		}
	}
	$global:bServiceRunning	= $false
}

function Stop-MyService
{
	$global:bRunService = $false # Signal main loop to exit
	$CountDown = 30 # Maximum wait for loop to exit
	while($global:bServiceRunning -and $Countdown -gt 0)
	{
		Start-Sleep -Seconds 1 # wait for your main loop to exit
		$Countdown = $Countdown - 1
	}
	# Place code to be executed on service stop here
	# Close files and connections, terminate jobs and
	# use remove-module to unload blocking modules
}

function Pause-MyService
{
	# Service is being paused
	# Save state 
	$global:bServicePaused = $true
	# Note that the thread your PowerShell script is running on is not suspended on 'pause'.
	# It is your responsibility in the service loop to pause processing until a 'continue' command is issued.
	# It is recommended to sleep for longer periods between loop iterations when the service is paused.
	# in order to prevent excessive CPU usage by simply waiting and looping.
}

function Continue-MyService
{
	# Service is being continued from a paused state
	# Restore any saved states if needed
	$global:bServicePaused = $false
}


]]></Code>
  <TV>0</TV>
</File>